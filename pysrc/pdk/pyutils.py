"""
Utilities for Python internals.

FOG 12.2002
"""

__docformat__ = "epytext"

__author__ = "F Oliver Gathmann"
__date__ = "$Date$"
__revision__ = "$Rev$"
__source__ = "$URL::                                                          $"

__all__ = ['dump_function',
           'exec_doc_test',
           'exec_main_doc_test',
           'get_bases',
           'get_caller_name',
           'get_full_class_name',
           'get_function_signature',
           'get_method_signature',
           'get_method_names',
           'get_methods',
           'get_module_name',
           'get_public_method_names',
           'get_public_methods',
           'get_word_length',
           'get_system_descriptor',
           'get_thread_name',
           'get_traceback',
           'import_module',
           'install_contract_import_hook'
           'is_main_thread',
           'is_standard_sequence_type',
           'load_function',
           'resolve_class',
           'resolve_module',
           'resolve_name',
           ]

#------------------------------------------------------------------------------
# standard library imports:
#
import cStringIO
import doctest
import imp
import inspect
import marshal
import math
import new
import os
import sys
import traceback
import types
from threading import currentThread

#------------------------------------------------------------------------------
# extension module imports:
#

#------------------------------------------------------------------------------
# pdk imports:
#

#------------------------------------------------------------------------------
# helper functions:
#

#------------------------------------------------------------------------------
# functions:
#

def get_module_name(obj):
    """
    Attempts to determine the name of the module in which the given object
    is defined.

    This works for code objects, user-defined functions and methods, instances
    with a __call__ method, and classes; for all other object types, the
    function returns C{None}.

    @param obj: object to obtain the module name for
    @type obj: see description
    @return: module name (string), or C{None}
    """
    obj_type = type(obj)
    if obj_type is types.CodeType:
        name = obj.co_filename
    elif obj_type is types.FunctionType:
        name = obj.func_code.co_filename
    elif obj_type is types.MethodType:
        name = obj.im_func.func_code.co_filename
    elif obj_type is types.InstanceType and hasattr(obj, '__call__'):
        name = obj.__call__.im_func.func_code.co_filename
    elif obj_type is types.ClassType:
        name = obj.__module__
    else:
        name = None
    return name


class _DocTestExecutor(object):
    """
    Executes a doctest-style doc string in a buffer

    Sometimes you want to play around with the objects generated by your
    test code interactively on a command prompt. This class allows you to
    execute doc strings written in doctest style(i.e., verbatim recordings
    of previous interactive sessions) within your current buffer.
    """

    class _TrailingWhitespaceInsensitiveOutputChecker(doctest.OutputChecker):
        def __init__(self, ignore_trailing_whitespace_flag):
            self.__ignore_trailing_whitespace_flag = \
                                        ignore_trailing_whitespace_flag

        def check_output(self, want, got, option_flags):
            """
            Overrides L{doctest.OutputChecker} implementing the "ignore
            trailing whitespace" option.
            """
            is_ok = doctest.OutputChecker.check_output(self, want, got,
                                                     option_flags)
            if not is_ok \
               and option_flags & self.__ignore_trailing_whitespace_flag:
                wants = want.split(os.linesep)
                gots = got.split(os.linesep)
                is_ok = len(wants) == len(gots)
                if is_ok:
                    for want_line, got_line in zip(wants, gots):
                        iLineLen = len(want_line)
                        is_ok = got_line[:iLineLen] == want_line and \
                              got_line[iLineLen:].isspace()
                        if not is_ok:
                            break
            return is_ok

    class _NonCopyableNonClearableDict(dict):
        def copy(self):
            return self

        def clear(self):
            pass

    @staticmethod
    def run(testObject, name_space=None):
        """
        Runs this doc test executor with the given test object in the given
        namespace.

        @param testObject: object to test. If this is a string, it is run as
          is; otherwise, its C{__doc__} attribute is used
        @type testObject: string or an arbitrary object with a C{__doc__}
          attribute
        @param name_space: namespace to execute the test in (defaults to the
          C{__main__} module)
        @type name_space: dictionary mapping names (strings) to arbitrary
          objects
        @note: when passing in a custom L{name_space} argument, beware that the
          doctest runner also inserts the C{__builtin__} module into your
          namespace
        """
        # Register our special IGNORE_TRAILING_WHITESPACE option.
        flag = doctest.register_optionflag('IGNORE_TRAILING_WHITESPACE')
        # Set up a doc tester with our special dict.
        custom_name_space = _DocTestExecutor._NonCopyableNonClearableDict()
        finder = doctest.DocTestFinder()
        if isinstance(testObject, basestring):
            name = 'doctest'
        else:
            name = testObject.__name__
        tests = finder.find(testObject, name=name, globs=custom_name_space)
        checker = \
           _DocTestExecutor._TrailingWhitespaceInsensitiveOutputChecker(flag)
        tester = doctest.DocTestRunner(checker=checker,
                                        verbose=False)
        for test in tests:
            # Run the doc test(s).
            tester.run(test)
        # Now, update our name space with our newly created variables for
        # further interactive use (but *only* with those to avoid overwriting
        # things, e.g. default instances!).
        if name_space is None:
            name_space = sys.modules['__main__'].__dict__
        for key, value in custom_name_space.items():
            if not key in name_space:
                name_space[key] = value

exec_doc_test = _DocTestExecutor.run


def exec_main_doc_test():
    """
    Calls L{exec_doc_test} on the C{__main__} module.
    """
    exec_doc_test(sys.modules['__main__'])


def import_module(file_name, search_paths=None):
    """
    Loads the specified file as a module with the imp hooks.

    @param file_name: file name of the module to import; either a full path
      name or a base name without path information, in which case the
      directories in L{search_paths} are used to find the file
    @type file_name: string
    @param search_paths: list of search directories
    @type search_paths: list of strings
    @return: imported module object
    """
    if search_paths is None:
        search_paths = []
    if os.sep in file_name:
        file_dir, base_name = os.path.split(file_name)
        search_paths = [file_dir]
    else:
        base_name = file_name
    base_name_root = os.path.splitext(base_name)[0]
    # the explicit conversion to a string is necessary for
    # imp.find_module to work:
    mod_file, mod_file_name, descr = \
         imp.find_module(str(base_name_root),
                         [str(search_path) for search_path in search_paths])
    try:
        module = imp.load_module(base_name_root, mod_file, mod_file_name,
                                  descr)
        return module
    finally:
        if mod_file:
            mod_file.close()


def get_bases(cls, reverse=True):
    """
    Returns a list of all super classes of a class.

    This works for both old- and new-style classes.

    @param cls: class to find super classes for
    @type cls: L{type} or L{classobj}
    @param reverse: if set, place classes high in the hierachy last
      in the list
    @type reverse: L{bool}
    @return: list of super classes (class objects) for L{cls}
    """
    if issubclass(cls, object):
        super_classes = cls.mro()[1:]
    else:
        check_index = 0
        super_classes = list(cls.__bases__)
        while True:
            prev_len = len(super_classes)
            for super_class in super_classes[check_index:]:
                for super_super_class in super_class.__bases__:
                    if not super_super_class in super_classes:
                        super_classes.append(super_super_class)
            if len(super_classes) == prev_len:
                break
            check_index = prev_len
    if reverse:
        # now, classes higher in the tree will be *last* in the iteration
        super_classes.reverse()
    return super_classes


def get_full_class_name(instance):
    """
    Returns the full dotted identifier of the given instance's class.

    @param instance: instance to find the dotted identifier for
    @type instance: instance object
    @return: full dotted identifier (string) of the instance's class
    """
    return '%s.%s' % (instance.__class__.__module__,
                      instance.__class__.__name__)


def get_caller_name():
    """
    Returns the name of the callable from the last execution frame (relative
    to the caller of this function).

    @return: name of the callable from the last execution frame (string)
    """
    return inspect.getouterframes(inspect.currentframe())[2][3]


def get_function_signature(func):
    """
    Returns a tuple of positional argument names and a dictionary mapping
    keyword names to default keyword values for the given function object.

    @param func: function to get the signature for
    @type func: callable object
    @return: tuple of positional argument names (strings) and a dictionary
      mapping keyword names (strings) to default keyword values (arbitrary
      objects)
    """
    defs = func.func_defaults
    code = func.func_code
    if defs is None:
        num_args = code.co_argcount
    else:
        num_args = code.co_argcount - len(defs)
    arg_names = code.co_varnames[:num_args]
    if not defs is None:
        options = dict(zip(code.co_varnames[num_args:num_args+len(defs)],
                           defs))
    else:
        options = dict()
    return arg_names, options


def get_method_signature(method):
    """
    Calls L{get_function_signature} on the given method object and chops off
    the C{self} argument from the tuple of argument names.

    @param method: function to get the signature for
    @type method: instance method
    @return: tuple of positional argument names (strings) and a dictionary
      mapping keyword names (strings) to default keyword values (arbitrary
      objects)
    """
    arg_names, options = get_function_signature(method.im_func)
    return arg_names[1:], options


def get_method_names(cls, include_inherited=True):
    """
    Returns a list of all method names for the given class.

    @param cls: class to seach for methods
    @type cls: type or class object
    @param include_inherited: if set, names from all inherited methods
      are also returned
    @type include_inherited: Boolean
    @return: list of method names (strings)
    """
    if include_inherited:
        lstNames = dir(cls)
    else:
        lstNames = cls.__dict__.keys()
    return [name for name in lstNames
            if callable(getattr(cls, name))]


def get_public_method_names(cls, include_inherited=True):
    """
    Like L{get_method_names}, but only returns public method names.
    """
    # FIXME: strictly speaking, we should be using an isPublic function here
    return [name for name in get_method_names(cls, include_inherited)
            if name[0] != '_' ]


def get_methods(cls, include_inherited=True):
    """
    Returns a dictionary of all methods of the given class.

    Calls L{get_method_names}; see there for more details.

    @return: dictionary mapping method names (strings) to methods (instance
      method objects)
    """
    return dict([(name, getattr(cls, name))
                  for name in get_method_names(cls, include_inherited)])


def get_public_methods(cls, include_inherited=True):
    """
    Like L{get_methods}, but only returns public methods.
    """
    return dict([(name, getattr(cls, name))
                 for name in get_public_method_names(cls, include_inherited)])


def resolve_module(module_name, global_name_space=None, local_name_space=None):
    """
    Imports the module of the given name, which may be a dotted path, using
    the given global and local namespaces.

    @param module_name: name of module to import
    @type module_name: string
    @param global_name_space: global namespace; defaults to the C{__main__}
      namespace
    @type global_name_space: dictionary mapping names (strings) to values
      (arbitrary objects)
    @param local_name_space: local namespace; defaults to the empty namespace
    @type local_name_space: dictionary mapping names (strings) to values
      (arbitrary objects)
    @return: imported module (module object)
    """
    if global_name_space is None:
        global_name_space = sys.modules['__main__'].__dict__
    if local_name_space is None:
        local_name_space = {}
    if not module_name.find('.') == -1:
        module = __import__(module_name,
                            global_name_space, local_name_space,
                            [module_name[:module_name.rfind('.')]])
    else:
        try:
            module = global_name_space[module_name]
            do_import = not isinstance(module, types.ModuleType)
        except KeyError:
            do_import = True
        if do_import:
            module = \
                __import__(module_name, global_name_space, local_name_space)
    return module


def resolve_name(name, global_name_space=None, local_name_space=None):
    """
    Resolves dotted identifiers as python objects.

    Dotted identifiers are names specified like this:

        C{<package>.<subpackage1>.<...>.<name>}

    If L{name} contains a dot, calls L{resolve_module} on the module prefix
    with L{global_name_space} and L{local_name_space} as arguments and then
    returns the object which L{name} is referring to as the module's attribute.
    Otherwise, L{name} is looked up in C{global_name_space}; if it is not found
    there either, L{resolve_module} is called on L{name}.

    See L{resolve_module} for more details.

    @param name: name to resolve
    @type name: string
    @param global_name_space: global namespace to use for name resolution
    @type global_name_space: dictionary mapping names (strings) to values
      (arbitrary objects)
    @param local_name_space: local namespace to use for name resolution
    @type global_name_space: dictionary mapping names (strings) to values
      (arbitrary objects)
    @return: resolved object (arbitrary object)
    """
    if '.' in name:
        # If a dot is in the identifier, we are trying to resolve a
        # reference in a module or package. We also support dynamic
        # importing of those
        pos = name.rfind('.')
        module_name = name[:pos]
        module = resolve_module(module_name, global_name_space, local_name_space)
        resolved = getattr(module, name[pos+1:])
    else:
        if global_name_space is None:
            global_name_space = sys.modules['__main__'].__dict__
        try:
            resolved = global_name_space[name]
        except KeyError:
            # Assume we have a module.
            resolved = resolve_module(name,
                                      global_name_space, local_name_space)
    return resolved


def resolve_class(name, global_name_space=None, local_name_space=None):
    """
    See the more general L{resolve_name}.
    """
    return resolve_name(name, global_name_space, local_name_space)


def get_traceback():
    """
    Fetches the last traceback from L{sys.exc_info} and returns it as a
    formatted string.

    @return: formatted traceback (string)
    """
    buf = cStringIO.StringIO()
    traceback.print_exc(file = buf)
    return buf.getvalue()


def get_word_length():
    """
    Returns the number of bits in a system word.

    Assumes the system uses a binary representation with a sign bit.

    @return: number of bits in system word (integer)
    """
    return int(round(math.log(sys.maxint)/math.log(2)))+1


def get_system_descriptor():
    """
    Returns a string consisting of three parts that uniquely identify the
    system this code is run on: ::

            <platform> + "_" +  <word length> + "bit_" + <python version>

    @return: system descriptor (string)
    """
    word_length = get_word_length()
    if sys.platform[:3] == 'win':
        platform = 'win_%dbit' % word_length
    else:
        platform = '%s_%dbit' % (sys.platform, word_length)
    return "%s_v%d%d" % ((platform,) + sys.version_info[:2])


def dump_function(func):
    """
    Dumps the given function into a pickleable tuple which can then be
    passed to L{load_function} to re-build the function.

    Uses the builtin C{marshal} module to do the low-level work.

    @param func: function to dump
    @type func: function object
    @return: 3-tuple of strings containing the dumped function data
    """
    code_object = marshal.dumps(func.func_code)
    defaults = func.func_defaults
    if not defaults is None:
        defaults_string = marshal.dumps(defaults)
    else:
        defaults_string = marshal.dumps(())
    return func.__name__, code_object, defaults_string


def load_function(dump_values):
    """
    Creates a function object from the given argument tuple created in a
    former call to L{dump_function}.

    @param dump_values: value returned by a call to L{dump_function}
    @type dumpValue: 3-tuple of strings
    @return: new loaded function (function object)
    """
    name, code_object, defaults_string = dump_values
    return new.function(marshal.loads(code_object),
                        globals(),
                        name,
                        marshal.loads(defaults_string))


def get_thread_name():
    """
    Returns the name of the current thread.

    @return: name of current thread (string)
    """
    return currentThread().getName()


def is_main_thread():
    """
    Checks if the current thread is the main thread.

    @return: check result (Boolean)
    """
    return currentThread().getName() == 'MainThread'


def is_standard_sequence_type(test_object):
    """
    Checks if the given object is an instance of the three standard sequence
    types C{list}, C{tuple}, and Numpy C{array}.

    @param test_object: object to check
    @type test_object: arbitrary object
    @return: test result (Boolean)
    """
    from numpy import ndarray
    return isinstance(test_object, (list, tuple, ndarray))


def install_contract_import_hook(module_name):
    """
    Set up custom import hook to apply contracts to modules

    @param module_name: the module name
    @type module_name: string
    """
    # TODO: re-implement this using PEP 302 import hooks
    import __builtin__
    from imp import C_EXTENSION
    from inspect import getmoduleinfo
    from pdk.contrib import contract
    originalImport = __builtin__.__import__
    def custom_import(name, *args, **kwargs):
        """Custom import hook to apply contracts to CeLMA modules"""
        new_import = name not in sys.modules
        mod = originalImport(name, *args, **kwargs) # pylint: disable-msg=W0142
        if hasattr(mod, '__file__'):
            moduleInfo = getmoduleinfo(mod.__file__)
            if (new_import and
                name.startswith('%s.' % module_name) and
                moduleInfo is not None and
                moduleInfo[3] != C_EXTENSION):
                contract.checkmod(name)
        return mod
    __builtin__.__import__ = custom_import
